---
import styles from '@/styles/TechStack.module.css';
import TechGrid from './TechGrid.astro';
import { techStackData } from '@/data/techStack';

// 動態生成菱形數量
const totalLayers = techStackData.length;
---
<section id="tech-stack" class={`${styles.container} px-[5%] py-16 md:py-24 lg:py-28`}>
    <div class={styles.progressBar}>
      <div class={styles.progressFill}></div>
    </div>

    <!-- Hero Section -->
    <section class={styles.hero}>
      <h1>技術檻</h1>
      <p>這裡是我常用的技術組合</p>
      <div class={styles.scrollHint}>向下滾動探索 ↓</div>
    </section>

    <!-- 主要容器 -->
    <div class={styles.mainContainer}>
      <!-- 菱形堆疊 -->
      <div class={styles.diamondStack}>
        {techStackData.map((_, index) => (
          <div class={`${styles.diamond} ${styles.invisible}`} data-diamond-layer={index}></div>
        ))}
      </div>

      <!-- 動態技術層級 -->
      {techStackData.map((layer, index) => (
        <div class={`${styles.techInfo} ${styles[layer.position]} ${styles.invisible} sm:mt-20`} data-info-layer={index}>
          <h2 class={styles.techTitle}>{layer.title}</h2>
          <p class={styles.techSubtitle}>{layer.subtitle}</p>
          <TechGrid technologies={layer.technologies} />
        </div>
      ))}
    </div>
</section>

    <script define:vars={{ totalLayers, styles }}>
      // 滾動控制變數
      let currentLayer = -1;

      // 檢測是否為移動設備
      function isMobile() {
        return window.innerWidth <= 768;
      }

      // 計算 TechStack section 的開始位置
      function getTechStackOffset() {
        const techStackElement = document.getElementById('tech-stack');
        return techStackElement ? techStackElement.offsetTop : 0;
      }

      // 更新進度條
      function updateProgressBar() {
        const scrollTop = window.pageYOffset;
        const techStackOffset = getTechStackOffset();
        const techStackElement = document.getElementById('tech-stack');
        
        if (techStackElement) {
          const windowHeight = window.innerHeight;
          const heroHeight = windowHeight;
          const layerScrollHeight = windowHeight * 1.2;
          const effectiveHeight = heroHeight + (totalLayers * layerScrollHeight);
          
          const progress = Math.max(0, Math.min(1, (scrollTop - techStackOffset) / effectiveHeight));
          const progressFill = techStackElement.querySelector('[class*="progressFill"]');
          if (progressFill) {
            progressFill.style.width = (progress * 100) + '%';
          }
        }
      }

      // 顯示指定層級
      function showLayer(layerIndex) {
        if (layerIndex === currentLayer) return;

        currentLayer = layerIndex;

        // 在移動設備上的邏輯
        if (isMobile()) {
          const diamonds = document.querySelectorAll('#tech-stack [data-diamond-layer]');
          const techInfos = document.querySelectorAll('#tech-stack [data-info-layer]');
          
          if (layerIndex >= 0) {
            // 根據層級顯示對應數量的 diamond 和 tech-info
            diamonds.forEach((diamond, index) => {
              if (index <= layerIndex) {
                diamond.classList.add(styles.visible);
                diamond.classList.remove(styles.invisible);
              } else {
                diamond.classList.remove(styles.visible);
                diamond.classList.add(styles.invisible);
              }
            });
            
            techInfos.forEach((info, index) => {
              if (index <= layerIndex) {
                info.classList.add(styles.visible);
                info.classList.remove(styles.invisible);
              } else {
                info.classList.remove(styles.visible);
                info.classList.add(styles.invisible);
              }
            });
          } else {
            // 隱藏所有層級（超出 section 範圍或在 hero 區域）
            diamonds.forEach((diamond) => {
              diamond.classList.remove(styles.visible);
              diamond.classList.add(styles.invisible);
            });
            
            techInfos.forEach((info) => {
              info.classList.remove(styles.visible);
              info.classList.add(styles.invisible);
            });
          }
          return;
        }

        // 桌面版的原有邏輯
        // 顯示菱形
        const diamonds = document.querySelectorAll('#tech-stack [data-diamond-layer]');
        diamonds.forEach((diamond, index) => {
          if (layerIndex >= 0 && index <= layerIndex) {
            diamond.classList.add(styles.visible);
            diamond.classList.remove(styles.invisible);
          } else {
            diamond.classList.remove(styles.visible);
            diamond.classList.add(styles.invisible);
          }
        });

        // 顯示對應的技術資訊
        const techInfos = document.querySelectorAll('#tech-stack [data-info-layer]');
        techInfos.forEach((info, index) => {
          if (layerIndex >= 0 && index === layerIndex) {
            info.classList.add(styles.visible);
            info.classList.remove(styles.invisible);

          } else {
            info.classList.remove(styles.visible);
            info.classList.add(styles.invisible);
          }
        });
      }

      // 滾動事件處理
      function handleScroll() {
        const scrollTop = window.pageYOffset;
        const windowHeight = window.innerHeight;
        const techStackOffset = getTechStackOffset();
        const techStackElement = document.getElementById('tech-stack');
        
        if (!techStackElement) return;

        // 計算 TechStack 的有效滾動範圍（不使用整個 section 的高度）
        const heroHeight = windowHeight;
        const layerScrollHeight = windowHeight * 1.2; // 每層大約 1.2 個螢幕高度
        const effectiveHeight = heroHeight + (totalLayers * layerScrollHeight);
        const techStackBottom = techStackOffset + effectiveHeight;

                  // 更新進度條，但只在 TechStack section 範圍內顯示
          if (scrollTop >= techStackOffset && scrollTop <= techStackBottom) {
            updateProgressBar();
            const progressBar = techStackElement.querySelector('[class*="progressBar"]');
            if (progressBar) {
              progressBar.style.display = 'block';
            }
          } else {
            const progressBar = techStackElement.querySelector('[class*="progressBar"]');
            if (progressBar) {
              progressBar.style.display = 'none';
            }
          }

        // 移動設備邏輯：根據滾動進度逐步顯示 diamond
        if (isMobile()) {
          // 如果還沒滾動到 TechStack section 或已經超出 TechStack 有效範圍
          if (scrollTop < techStackOffset || scrollTop > techStackBottom) {
            showLayer(-1);
            return;
          }

          // 如果在 TechStack 的 hero 區域，不顯示任何 diamond
          if (scrollTop < techStackOffset + heroHeight) {
            showLayer(-1);
            return;
          }

          // 計算當前應該顯示的層級（hero 區域結束後開始）
          const techStackScrolled = scrollTop - (techStackOffset + heroHeight);
          const mainScrollHeight = effectiveHeight - heroHeight;
          const scrollProgress = techStackScrolled / mainScrollHeight;
          const targetLayer = Math.floor(scrollProgress * totalLayers);
          const clampedLayer = Math.max(0, Math.min(totalLayers - 1, targetLayer));

          showLayer(clampedLayer);
          return;
        }

        // 如果還沒滾動到 TechStack section 或已經超出 TechStack 有效範圍
        if (scrollTop < techStackOffset || scrollTop > techStackBottom) {
          showLayer(-1);
          return;
        }

        // 如果在 TechStack 的 hero 區域
        if (scrollTop < techStackOffset + heroHeight) {
          showLayer(-1);
          return;
        }

        // 計算當前應該顯示的層級
        const techStackScrolled = scrollTop - (techStackOffset + heroHeight);
        const mainScrollHeight = effectiveHeight - heroHeight;
        const scrollProgress = techStackScrolled / mainScrollHeight;
        const targetLayer = Math.floor(scrollProgress * totalLayers);
        const clampedLayer = Math.max(0, Math.min(totalLayers - 1, targetLayer));

        showLayer(clampedLayer);
      }

      // 窗口大小改變時重新初始化
      function handleResize() {
        // 重置當前層級，強制重新計算
        currentLayer = -1;
        handleScroll();
      }

      // 初始化
      window.addEventListener('scroll', handleScroll);
      window.addEventListener('resize', handleResize);

      // 初始檢查
      handleScroll();

      // 平滑滾動到第一層
      const scrollHint = document.querySelector('#tech-stack [class*="scrollHint"]');
      if (scrollHint) {
        scrollHint.addEventListener('click', () => {
          const techStackOffset = getTechStackOffset();
          window.scrollTo({
            top: techStackOffset + window.innerHeight,
            behavior: 'smooth',
          });
        });
      }

      // 菱形旋轉動畫
      function animateDiamonds() {
        const diamonds = document.querySelectorAll(`#tech-stack [data-diamond-layer][class*="${styles.visible}"]`);
        diamonds.forEach((diamond, index) => {
          diamond.style.transform = `rotate(${
            45 + Math.sin(Date.now() * 0.001 + index) * 5
          }deg)`;
        });
        requestAnimationFrame(animateDiamonds);
      }

      animateDiamonds();
    </script>
